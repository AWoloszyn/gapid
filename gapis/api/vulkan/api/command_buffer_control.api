// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Based off of the original vulkan.h header file which has the following
// license.

// Copyright (c) 2015 The Khronos Group Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and/or associated documentation files (the
// "Materials"), to deal in the Materials without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Materials, and to
// permit persons to whom the Materials are furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Materials.
//
// THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

//////////////////
// Command pool //
//////////////////

@internal class CommandPoolObject {
  @unused VkDevice                                       Device
  @unused VkCommandPool                                  VulkanHandle
  @unsued VkCommandPoolCreateFlags                       Flags
  @unused u32                                            QueueFamilyIndex
  @unused map!(VkCommandBuffer, ref!CommandBufferObject) CommandBuffers
  @unused ref!VulkanDebugMarkerInfo                      DebugInfo
}

@indirect("VkDevice")
cmd VkResult vkCreateCommandPool(
    VkDevice                       device,
    const VkCommandPoolCreateInfo* pCreateInfo,
    AllocationCallbacks            pAllocator,
    VkCommandPool*                 pCommandPool) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkCommandPoolCreateInfo") }
  create_info := pCreateInfo[0]
  // handle pNext
  if create_info.pNext != null {
    numPNext := numberOfPNext(create_info.pNext)
    next := MutableVoidPtr(as!void*(create_info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      _ = sType
      // TODO: handle extensions for VkCommandPoolCreateInfo
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }

  handle := ?
  if pCommandPool == null { vkErrorNullPointer("VkCommandPool") }
  pCommandPool[0] = handle
  commandPoolObject := new!CommandPoolObject(Device: device,
    VulkanHandle:             handle,
    Flags:                    create_info.flags,
    QueueFamilyIndex:         create_info.queueFamilyIndex)
  CommandPools[handle] = commandPoolObject

  return ?
}

@indirect("VkDevice")
cmd void vkDestroyCommandPool(
    VkDevice                     device,
    VkCommandPool                commandPool,
    AllocationCallbacks          pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if (commandPool != as!VkCommandPool(0)) {
    if !(commandPool in CommandPools) { vkErrorInvalidCommandPool(commandPool) }
    for _ , k , _ in CommandPools[commandPool].CommandBuffers {
      freeCmd(k)
      delete(CommandBuffers, k)
    }
    delete(CommandPools, commandPool)
  }
}

@indirect("VkDevice")
cmd VkResult vkResetCommandPool(
    VkDevice                device,
    VkCommandPool           commandPool,
    VkCommandPoolResetFlags flags) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(commandPool in CommandPools) { vkErrorInvalidCommandPool(commandPool) }
  pool := CommandPools[commandPool]
  for _ , _ , b in pool.CommandBuffers {
    b.BeginInfo = null
    b.Recording = NOT_STARTED
    resetCommandBuffer(b)
  }
  return ?
}

////////////////////
// Command buffer //
////////////////////

enum RecordingState {
  NOT_STARTED  = 0,
  RECORDING    = 1,
  COMPLETED    = 2,
  TO_BE_RESET  = 3
}

@internal class DeviceGroupBegin {
  u32         DeviceMask
}

@internal class CommandBufferBegin {
  VkCommandBufferUsageFlags     Flags
  bool                          Inherited
  VkRenderPass                  InheritedRenderPass
  u32                           InheritedSubpass
  VkFramebuffer                 InheritedFramebuffer
  VkBool32                      InheritedOcclusionQuery
  VkQueryControlFlags           InheritedQueryFlags
  VkQueryPipelineStatisticFlags InheritedPipelineStatsFlags
  ref!DeviceGroupBegin          DeviceGroupBegin
}

enum CommandType {
  cmd_vkCmdBindPipeline                  = 0,
  cmd_vkCmdSetViewport                   = 1,
  cmd_vkCmdSetScissor                    = 2,
  cmd_vkCmdSetLineWidth                  = 3,
  cmd_vkCmdSetDepthBias                  = 4,
  cmd_vkCmdSetBlendConstants             = 5,
  cmd_vkCmdSetDepthBounds                = 6,
  cmd_vkCmdSetStencilCompareMask         = 7,
  cmd_vkCmdSetStencilWriteMask           = 8,
  cmd_vkCmdSetStencilReference           = 9,
  cmd_vkCmdBindDescriptorSets            = 10,
  cmd_vkCmdBindIndexBuffer               = 11,
  cmd_vkCmdBindVertexBuffers             = 12,
  cmd_vkCmdDraw                          = 13,
  cmd_vkCmdDrawIndexed                   = 14,
  cmd_vkCmdDrawIndirect                  = 15,
  cmd_vkCmdDrawIndexedIndirect           = 16,
  cmd_vkCmdDispatch                      = 17,
  cmd_vkCmdDispatchIndirect              = 18,
  cmd_vkCmdCopyBuffer                    = 19,
  cmd_vkCmdCopyImage                     = 20,
  cmd_vkCmdBlitImage                     = 21,
  cmd_vkCmdCopyBufferToImage             = 22,
  cmd_vkCmdCopyImageToBuffer             = 23,
  cmd_vkCmdUpdateBuffer                  = 24,
  cmd_vkCmdFillBuffer                    = 25,
  cmd_vkCmdClearColorImage               = 26,
  cmd_vkCmdClearDepthStencilImage        = 27,
  cmd_vkCmdClearAttachments              = 28,
  cmd_vkCmdResolveImage                  = 29,
  cmd_vkCmdSetEvent                      = 30,
  cmd_vkCmdResetEvent                    = 31,
  cmd_vkCmdWaitEvents                    = 32,
  cmd_vkCmdPipelineBarrier               = 33,
  cmd_vkCmdBeginQuery                    = 34,
  cmd_vkCmdEndQuery                      = 35,
  cmd_vkCmdResetQueryPool                = 36,
  cmd_vkCmdWriteTimestamp                = 37,
  cmd_vkCmdCopyQueryPoolResults          = 38,
  cmd_vkCmdPushConstants                 = 39,
  cmd_vkCmdBeginRenderPass               = 40,
  cmd_vkCmdNextSubpass                   = 41,
  cmd_vkCmdEndRenderPass                 = 42,
  cmd_vkCmdExecuteCommands               = 43,
  cmd_vkCmdDebugMarkerBeginEXT           = 44,
  cmd_vkCmdDebugMarkerEndEXT             = 45,
  cmd_vkCmdDebugMarkerInsertEXT          = 46,
  cmd_vkCmdDrawIndirectCountKHR          = 47,
  cmd_vkCmdDrawIndexedIndirectCountKHR   = 48,
  cmd_vkCmdDrawIndirectCountAMD          = 49,
  cmd_vkCmdDrawIndexedIndirectCountAMD   = 50,
  cmd_vkCmdBeginDebugUtilsLabelEXT       = 51,
  cmd_vkCmdEndDebugUtilsLabelEXT         = 52,
  cmd_vkCmdInsertDebugUtilsLabelEXT      = 53,
  cmd_vkCmdSetDeviceMaskKHR              = 54,
  cmd_vkCmdSetDeviceMask                 = 55,
  cmd_vkCmdDispatchBaseKHR               = 56,
  cmd_vkCmdDispatchBase                  = 57,
  cmd_vkNoCommand                        = 0xFFFFFFFF
}

enum SemaphoreUpdate {
  None     = 0,
  Unsignal = 1,
  Signal   = 2
}

@internal class QueuedSparseBinds {
  @unused map!(VkBuffer, ref!SparseMemoryBinds)     BufferBinds
  @unused map!(VkImage, ref!SparseMemoryBinds)      OpaqueImageBinds
  @unused map!(VkImage, ref!SparseImageMemoryBinds) ImageBinds
}

@internal class CommandReference {
  @unused VkCommandBuffer       Buffer
  @unused u32                   CommandIndex
  @unused CommandType           Type
  @unused u32                   MapIndex
}

@internal class BufferCommands {
  @untrackedMap dense_map!(u32, ref!vkCmdBindPipelineArgs)           vkCmdBindPipeline
  u32 vkCmdBindPipelineCount
  @untrackedMap dense_map!(u32, ref!vkCmdSetViewportArgs)            vkCmdSetViewport
  u32 vkCmdSetViewportCount
  @untrackedMap dense_map!(u32, ref!vkCmdSetScissorArgs)             vkCmdSetScissor
  u32 vkCmdSetScissorCount
  @untrackedMap dense_map!(u32, ref!vkCmdSetLineWidthArgs)           vkCmdSetLineWidth
  u32 vkCmdSetLineWidthCount
  @untrackedMap dense_map!(u32, ref!vkCmdSetDepthBiasArgs)           vkCmdSetDepthBias
  u32 vkCmdSetDepthBiasCount
  @untrackedMap dense_map!(u32, ref!vkCmdSetBlendConstantsArgs)      vkCmdSetBlendConstants
  u32 vkCmdSetBlendConstantsCount
  @untrackedMap dense_map!(u32, ref!vkCmdSetDepthBoundsArgs)         vkCmdSetDepthBounds
  u32 vkCmdSetDepthBoundsCount
  @untrackedMap dense_map!(u32, ref!vkCmdSetStencilCompareMaskArgs)  vkCmdSetStencilCompareMask
  u32 vkCmdSetStencilCompareMaskCount
  @untrackedMap dense_map!(u32, ref!vkCmdSetStencilWriteMaskArgs)    vkCmdSetStencilWriteMask
  u32 vkCmdSetStencilWriteMaskCount
  @untrackedMap dense_map!(u32, ref!vkCmdSetStencilReferenceArgs)    vkCmdSetStencilReference
  u32 vkCmdSetStencilReferenceCount
  @untrackedMap dense_map!(u32, ref!vkCmdBindDescriptorSetsArgs)     vkCmdBindDescriptorSets
  u32 vkCmdBindDescriptorSetsCount
  @untrackedMap dense_map!(u32, ref!vkCmdBindIndexBufferArgs)        vkCmdBindIndexBuffer
  u32 vkCmdBindIndexBufferCount
  @untrackedMap dense_map!(u32, ref!vkCmdBindVertexBuffersArgs)      vkCmdBindVertexBuffers
  u32 vkCmdBindVertexBuffersCount
  @untrackedMap dense_map!(u32, ref!vkCmdDrawArgs)                   vkCmdDraw
  u32 vkCmdDrawCount
  @untrackedMap dense_map!(u32, ref!vkCmdDrawIndexedArgs)            vkCmdDrawIndexed
  u32 vkCmdDrawIndexedCount
  @untrackedMap dense_map!(u32, ref!vkCmdDrawIndirectArgs)           vkCmdDrawIndirect
  u32 vkCmdDrawIndirectCount
  @untrackedMap dense_map!(u32, ref!vkCmdDrawIndexedIndirectArgs)    vkCmdDrawIndexedIndirect
  u32 vkCmdDrawIndexedIndirectCount
  @untrackedMap dense_map!(u32, ref!vkCmdDispatchArgs)               vkCmdDispatch
  u32 vkCmdDispatchCount
  @untrackedMap dense_map!(u32, ref!vkCmdDispatchIndirectArgs)       vkCmdDispatchIndirect
  u32 vkCmdDispatchIndirectCount
  @untrackedMap dense_map!(u32, ref!vkCmdCopyBufferArgs)             vkCmdCopyBuffer
  u32 vkCmdCopyBufferCount
  @untrackedMap dense_map!(u32, ref!vkCmdCopyImageArgs)              vkCmdCopyImage
  u32 vkCmdCopyImageCount
  @untrackedMap dense_map!(u32, ref!vkCmdBlitImageArgs)              vkCmdBlitImage
  u32 vkCmdBlitImageCount
  @untrackedMap dense_map!(u32, ref!vkCmdCopyBufferToImageArgs)      vkCmdCopyBufferToImage
  u32 vkCmdCopyBufferToImageCount
  @untrackedMap dense_map!(u32, ref!vkCmdCopyImageToBufferArgs)      vkCmdCopyImageToBuffer
  u32 vkCmdCopyImageToBufferCount
  @untrackedMap dense_map!(u32, ref!vkCmdUpdateBufferArgs)           vkCmdUpdateBuffer
  u32 vkCmdUpdateBufferCount
  @untrackedMap dense_map!(u32, ref!vkCmdFillBufferArgs)             vkCmdFillBuffer
  u32 vkCmdFillBufferCount
  @untrackedMap dense_map!(u32, ref!vkCmdClearColorImageArgs)        vkCmdClearColorImage
  u32 vkCmdClearColorImageCount
  @untrackedMap dense_map!(u32, ref!vkCmdClearDepthStencilImageArgs) vkCmdClearDepthStencilImage
  u32 vkCmdClearDepthStencilImageCount
  @untrackedMap dense_map!(u32, ref!vkCmdClearAttachmentsArgs)       vkCmdClearAttachments
  u32 vkCmdClearAttachmentsCount
  @untrackedMap dense_map!(u32, ref!vkCmdResolveImageArgs)           vkCmdResolveImage
  u32 vkCmdResolveImageCount
  @untrackedMap dense_map!(u32, ref!vkCmdSetEventArgs)               vkCmdSetEvent
  u32 vkCmdSetEventCount
  @untrackedMap dense_map!(u32, ref!vkCmdResetEventArgs)             vkCmdResetEvent
  u32 vkCmdResetEventCount
  @untrackedMap dense_map!(u32, ref!vkCmdWaitEventsArgs)             vkCmdWaitEvents
  u32 vkCmdWaitEventsCount
  @untrackedMap dense_map!(u32, ref!vkCmdPipelineBarrierArgs)        vkCmdPipelineBarrier
  u32 vkCmdPipelineBarrierCount
  @untrackedMap dense_map!(u32, ref!vkCmdBeginQueryArgs)             vkCmdBeginQuery
  u32 vkCmdBeginQueryCount
  @untrackedMap dense_map!(u32, ref!vkCmdEndQueryArgs)               vkCmdEndQuery
  u32 vkCmdEndQueryCount
  @untrackedMap dense_map!(u32, ref!vkCmdResetQueryPoolArgs)         vkCmdResetQueryPool
  u32 vkCmdResetQueryPoolCount
  @untrackedMap dense_map!(u32, ref!vkCmdWriteTimestampArgs)         vkCmdWriteTimestamp
  u32 vkCmdWriteTimestampCount
  @untrackedMap dense_map!(u32, ref!vkCmdCopyQueryPoolResultsArgs)   vkCmdCopyQueryPoolResults
  u32 vkCmdCopyQueryPoolResultsCount
  @untrackedMap dense_map!(u32, ref!vkCmdPushConstantsArgs)          vkCmdPushConstants
  u32 vkCmdPushConstantsCount
  @untrackedMap dense_map!(u32, ref!vkCmdBeginRenderPassArgs)        vkCmdBeginRenderPass
  u32 vkCmdBeginRenderPassCount
  @untrackedMap dense_map!(u32, ref!vkCmdNextSubpassArgs)            vkCmdNextSubpass
  u32 vkCmdNextSubpassCount
  @untrackedMap dense_map!(u32, ref!vkCmdEndRenderPassArgs)          vkCmdEndRenderPass
  u32 vkCmdEndRenderPassCount
  @untrackedMap dense_map!(u32, ref!vkCmdExecuteCommandsArgs)        vkCmdExecuteCommands
  u32 vkCmdExecuteCommandsCount
  @untrackedMap dense_map!(u32, ref!vkCmdDebugMarkerBeginEXTArgs)    vkCmdDebugMarkerBeginEXT
  u32 vkCmdDebugMarkerBeginEXTCount
  @untrackedMap dense_map!(u32, ref!vkCmdDebugMarkerEndEXTArgs)      vkCmdDebugMarkerEndEXT
  u32 vkCmdDebugMarkerEndEXTCount
  @untrackedMap dense_map!(u32, ref!vkCmdDebugMarkerInsertEXTArgs)   vkCmdDebugMarkerInsertEXT
  u32 vkCmdDebugMarkerInsertEXTCount
  @untrackedMap dense_map!(u32, ref!vkCmdDrawIndirectCountKHRArgs)   vkCmdDrawIndirectCountKHR
  u32 vkCmdDrawIndirectCountKHRCount
  @untrackedMap dense_map!(u32, ref!vkCmdDrawIndexedIndirectCountKHRArgs)   vkCmdDrawIndexedIndirectCountKHR
  u32 vkCmdDrawIndexedIndirectCountKHRCount
  @untrackedMap dense_map!(u32, ref!vkCmdDrawIndirectCountAMDArgs)   vkCmdDrawIndirectCountAMD
  u32 vkCmdDrawIndirectCountAMDCount
  @untrackedMap dense_map!(u32, ref!vkCmdDrawIndexedIndirectCountAMDArgs)   vkCmdDrawIndexedIndirectCountAMD
  u32 vkCmdDrawIndexedIndirectCountAMDCount
  @untrackedMap dense_map!(u32, ref!vkCmdBeginDebugUtilsLabelEXTArgs)  vkCmdBeginDebugUtilsLabelEXT
  u32 vkCmdBeginDebugUtilsLabelEXTCount
  @untrackedMap dense_map!(u32, ref!vkCmdEndDebugUtilsLabelEXTArgs)    vkCmdEndDebugUtilsLabelEXT
  u32 vkCmdEndDebugUtilsLabelEXTCount
  @untrackedMap dense_map!(u32, ref!vkCmdInsertDebugUtilsLabelEXTArgs) vkCmdInsertDebugUtilsLabelEXT
  u32 vkCmdInsertDebugUtilsLabelEXTCount
  @untrackedMap dense_map!(u32, ref!vkCmdSetDeviceMaskKHRArgs)         vkCmdSetDeviceMaskKHR
  u32 vkCmdSetDeviceMaskKHRCount
  @untrackedMap dense_map!(u32, ref!vkCmdSetDeviceMaskArgs)            vkCmdSetDeviceMask
  u32 vkCmdSetDeviceMaskCount
  @untrackedMap dense_map!(u32, ref!vkCmdDispatchBaseKHRArgs)          vkCmdDispatchBaseKHR
  u32 vkCmdDispatchBaseKHRCount
  @untrackedMap dense_map!(u32, ref!vkCmdDispatchBaseArgs)             vkCmdDispatchBase
  u32 vkCmdDispatchBaseCount
}

@internal class AspectImageTransition {
  // This u64 is a combination of 2 u32s, (layer << 8 | level)
  map!(u64, VkImageLayout)                Layouts
}

@internal class  ImageTransitions {
  map!(VkImageAspectFlagBits, ref!AspectImageTransition) AspectTransitions
}

@internal class CommandBufferObject {
  @unused VkDevice                        Device
  @unused RecordingState                  Recording
  @unused VkCommandBuffer                 VulkanHandle
  @unused VkCommandPool                   Pool
  @unused VkCommandBufferLevel            Level
  @untrackedMap @unused
  dense_map!(u32, CommandReference)   CommandReferences
  @untracked @unused BufferCommands       BufferCommands
  @unused ref!CommandBufferBegin          BeginInfo
  @unused ref!VulkanDebugMarkerInfo       DebugInfo

  @unused
  map!(VkImage, ref!ImageTransitions)         ImageTransitions
  @unused
  ref!RenderPassObject                        CurrentRecordingRenderpass
  ref!FramebufferObject                       CurrentRecordingFramebuffer
  u32                                         CurrentRecordingSubpass
  ref!RenderPassObject                        PreviouslyStartedRenderpass
  ref!FramebufferObject                       PreviousFramebuffer
}

sub void RecordLayoutTransition(ref!CommandBufferObject obj, ref!ImageObject img, VkImageSubresourceRange rng, VkImageLayout new_layout) {
  if img != null {
    if !(img.VulkanHandle in obj.ImageTransitions) {
      obj.ImageTransitions[img.VulkanHandle] = new!ImageTransitions()
    }
    layerCount := imageSubresourceLayerCount(img, rng)
    levelCount := imageSubresourceLevelCount(img, rng)
    transitions := obj.ImageTransitions[img.VulkanHandle]

    for _ , _ , aspectBit in unpackImageAspectFlags(img, rng.aspectMask) {
      if !aspectBit in transitions.AspectTransitions {
          transitions.AspectTransitions[aspectBit] = new!AspectImageTransition()
      }
      aspectTransitions := transitions.AspectTransitions[aspectBit]
      for i in 0 .. levelCount {
        for j in 0 .. layerCount {
          level := rng.baseMipLevel + i
          layer := rng.baseArrayLayer + j
          aspectTransitions.Layouts[(as!u64(layer) << 8) | as!u64(level & 0xFF)] = new_layout
        }
      }
    }
  }
}

sub void MergeLayoutTransitions(ref!CommandBufferObject dst, ref!CommandBufferObject src) {
  for _, img, aspect_transitions in src.ImageTransitions {
    if !(img in dst.ImageTransitions) {
      dst.ImageTransitions[img] = new!ImageTransitions()
    }
    dst_transitions := dst.ImageTransitions[img]
    for _, aspect, transitions in aspect_transitions.AspectTransitions {
      if !aspect in dst_transitions.AspectTransitions {
        dst_transitions.AspectTransitions[aspect] = new!AspectImageTransition()
      }
      dstLayouts := dst_transitions.AspectTransitions[aspect]
      for _, k, v in transitions.Layouts {
        dstLayouts.Layouts[k] = v
      }
    }
  }
}

sub void AddCommand(
    ref!CommandBufferObject cb,
    CommandType     type,
    u32             mapPos) {
  commandIndex := as!u32(len(cb.CommandReferences))
  commandBuffer := cb.VulkanHandle
  cmd := CommandReference(
    Buffer: commandBuffer,
    CommandIndex: commandIndex,
    Type: type,
    MapIndex: mapPos,
  )
  if cb.Recording != RECORDING {
    vkErrorCommandBufferNotRecording(commandBuffer)
  }
  cb.CommandReferences[commandIndex] = cmd
  onCommandAdded(commandBuffer)
}

@threadSafety("system")
@indirect("VkDevice")
@override
@custom
cmd VkResult vkAllocateCommandBuffers(
    VkDevice                           device,
    const VkCommandBufferAllocateInfo* pAllocateInfo,
    VkCommandBuffer*                   pCommandBuffers) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pAllocateInfo == null { vkErrorNullPointer("VkCommandBufferAllocateInfo") }
  allocateInfo := pAllocateInfo[0]
  // handle pNext
  if allocateInfo.pNext != null {
    numPNext := numberOfPNext(allocateInfo.pNext)
    next := MutableVoidPtr(as!void*(allocateInfo.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      _ = sType
      // TODO: handle extensions for VkCommandBufferAllocateInfo
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }
  count := allocateInfo.commandBufferCount

  fence
  if pCommandBuffers == null { vkErrorNullPointer("VkCommandBuffer") }
  cb := pCommandBuffers[0:count]

  for i in (0 .. count) {
    command_buffer := ?
    cb[i] = command_buffer
    CommandBuffers[command_buffer] = new!CommandBufferObject(
      Device:        device,
      VulkanHandle:  command_buffer,
      Recording:     NOT_STARTED,
      Pool:          allocateInfo.commandPool,
      Level:         allocateInfo.level)
    command_pool := CommandPools[allocateInfo.commandPool]
    command_pool.CommandBuffers[command_buffer] = CommandBuffers[command_buffer]
  }
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@custom
cmd void vkFreeCommandBuffers(
    VkDevice               device,
    VkCommandPool          commandPool,
    u32                    commandBufferCount,
    const VkCommandBuffer* pCommandBuffers) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(commandPool in CommandPools) { vkErrorInvalidCommandPool(commandPool) }
  cb := pCommandBuffers[0:commandBufferCount]
  for i in (0 .. commandBufferCount) {
    buffer := cb[i]
    if buffer != as!VkCommandBuffer(0) {
      if !(buffer in CommandBuffers) {
        vkErrorInvalidCommandBuffer(buffer)
      } else {
        buffer_object := CommandBuffers[buffer]
        pool := buffer_object.Pool
        pool_object := CommandPools[pool]
        delete(pool_object.CommandBuffers, buffer)
        resetCmd(buffer)
        freeCmd(buffer)
        delete(CommandBuffers, buffer)
      }
    }
  }
}

extern void recordBeginCommandBuffer(VkCommandBuffer commandBuffer)
extern void recordEndCommandBuffer(VkCommandBuffer commandBuffer)

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd VkResult vkBeginCommandBuffer(
    VkCommandBuffer                 commandBuffer,
    const VkCommandBufferBeginInfo* pBeginInfo) {
  if pBeginInfo == null { vkErrorNullPointer("VkCommandBufferBeginInfo") }
  info := pBeginInfo[0]
  begin := new!CommandBufferBegin(Flags: info.flags,Inherited:  false)

  // handle pNext
  if info.pNext != null {
    numPNext := numberOfPNext(info.pNext)
    next := MutableVoidPtr(as!void*(info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      _ = sType
      switch sType {
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: {
          ext := as!VkDeviceGroupCommandBufferBeginInfo*(next.Ptr)[0:1][0]
          begin.DeviceGroupBegin = new!DeviceGroupBegin(
            DeviceMask: ext.deviceMask,
          )
        }
        default: {}
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }

  if !(commandBuffer in CommandBuffers) {
    vkErrorInvalidCommandBuffer(commandBuffer)
  } else {
    buff := CommandBuffers[commandBuffer]
    if (buff.Level == VK_COMMAND_BUFFER_LEVEL_SECONDARY) && (info.pInheritanceInfo != null) {
      inheritanceInfo := info.pInheritanceInfo[0]
      begin.Inherited = true
      begin.InheritedRenderPass = inheritanceInfo.renderPass
      begin.InheritedSubpass = inheritanceInfo.subpass
      begin.InheritedFramebuffer = inheritanceInfo.framebuffer
      begin.InheritedOcclusionQuery = inheritanceInfo.occlusionQueryEnable
      begin.InheritedQueryFlags = inheritanceInfo.queryFlags
      begin.InheritedPipelineStatsFlags = inheritanceInfo.pipelineStatistics
      // handle pBeginInfo->pInheritanceInfo->pNext
      if inheritanceInfo.pNext != null {
        numPNext := numberOfPNext(inheritanceInfo.pNext)
        next := MutableVoidPtr(as!void*(inheritanceInfo.pNext))
        for i in (0 .. numPNext) {
          sType := as!const VkStructureType*(next.Ptr)[0:1][0]
          _ = sType
          // TODO: handle extensions for VkCommandBufferInheritanceInfo
          next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
        }
      }
    }

    buff.BeginInfo = begin
    buff.Recording = RECORDING
    resetCommandBuffer(buff)
  }

  recordBeginCommandBuffer(commandBuffer)
  return ?
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd VkResult vkEndCommandBuffer(
    VkCommandBuffer commandBuffer) {
  if !(commandBuffer in CommandBuffers) {
    vkErrorInvalidCommandBuffer(commandBuffer)
  } else {
    buff := CommandBuffers[commandBuffer]
    if (buff.Recording != RECORDING) {
      vkErrorCommandBufferNotRecording(commandBuffer)
    }
    buff.Recording = COMPLETED
  }
  recordEndCommandBuffer(commandBuffer)
  return ?
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd VkResult vkResetCommandBuffer(
    VkCommandBuffer           commandBuffer,
    VkCommandBufferResetFlags flags) {
  if !(commandBuffer in CommandBuffers) {
    vkErrorInvalidCommandBuffer(commandBuffer)
  } else {
    buff := CommandBuffers[commandBuffer]
    buff.Recording = NOT_STARTED
    buff.BeginInfo = null
    resetCommandBuffer(buff)
  }
  return ?
}

sub void resetBufferCommands(ref!CommandBufferObject obj) {
  obj.BufferCommands.vkCmdBindPipelineCount = 0
  obj.BufferCommands.vkCmdSetViewportCount = 0
  obj.BufferCommands.vkCmdSetScissorCount = 0
  obj.BufferCommands.vkCmdSetLineWidthCount = 0
  obj.BufferCommands.vkCmdSetDepthBiasCount = 0
  obj.BufferCommands.vkCmdSetBlendConstantsCount = 0
  obj.BufferCommands.vkCmdSetDepthBoundsCount = 0
  obj.BufferCommands.vkCmdSetStencilCompareMaskCount = 0
  obj.BufferCommands.vkCmdSetStencilWriteMaskCount = 0
  obj.BufferCommands.vkCmdSetStencilReferenceCount = 0
  obj.BufferCommands.vkCmdBindDescriptorSetsCount = 0
  obj.BufferCommands.vkCmdBindIndexBufferCount = 0
  obj.BufferCommands.vkCmdBindVertexBuffersCount = 0
  obj.BufferCommands.vkCmdDrawCount = 0
  obj.BufferCommands.vkCmdDrawIndexedCount = 0
  obj.BufferCommands.vkCmdDrawIndirectCount = 0
  obj.BufferCommands.vkCmdDrawIndexedIndirectCount = 0
  obj.BufferCommands.vkCmdDispatchCount = 0
  obj.BufferCommands.vkCmdDispatchIndirectCount = 0
  obj.BufferCommands.vkCmdCopyBufferCount = 0
  obj.BufferCommands.vkCmdCopyImageCount = 0
  obj.BufferCommands.vkCmdBlitImageCount = 0
  obj.BufferCommands.vkCmdCopyBufferToImageCount = 0
  obj.BufferCommands.vkCmdCopyImageToBufferCount = 0
  obj.BufferCommands.vkCmdUpdateBufferCount = 0
  obj.BufferCommands.vkCmdFillBufferCount = 0
  obj.BufferCommands.vkCmdClearColorImageCount = 0
  obj.BufferCommands.vkCmdClearDepthStencilImageCount = 0
  obj.BufferCommands.vkCmdClearAttachmentsCount = 0
  obj.BufferCommands.vkCmdResolveImageCount = 0
  obj.BufferCommands.vkCmdSetEventCount = 0
  obj.BufferCommands.vkCmdResetEventCount = 0
  obj.BufferCommands.vkCmdWaitEventsCount = 0
  obj.BufferCommands.vkCmdPipelineBarrierCount = 0
  obj.BufferCommands.vkCmdBeginQueryCount = 0
  obj.BufferCommands.vkCmdEndQueryCount = 0
  obj.BufferCommands.vkCmdResetQueryPoolCount = 0
  obj.BufferCommands.vkCmdWriteTimestampCount = 0
  obj.BufferCommands.vkCmdCopyQueryPoolResultsCount = 0
  obj.BufferCommands.vkCmdPushConstantsCount = 0
  obj.BufferCommands.vkCmdBeginRenderPassCount = 0
  obj.BufferCommands.vkCmdNextSubpassCount = 0
  obj.BufferCommands.vkCmdEndRenderPassCount = 0
  obj.BufferCommands.vkCmdExecuteCommandsCount = 0
  obj.BufferCommands.vkCmdDebugMarkerBeginEXTCount = 0
  obj.BufferCommands.vkCmdDebugMarkerEndEXTCount = 0
  obj.BufferCommands.vkCmdDebugMarkerInsertEXTCount = 0
  obj.BufferCommands.vkCmdDrawIndirectCountKHRCount = 0
  obj.BufferCommands.vkCmdDrawIndexedIndirectCountKHRCount = 0
  obj.BufferCommands.vkCmdDrawIndirectCountAMDCount = 0
  obj.BufferCommands.vkCmdDrawIndexedIndirectCountAMDCount = 0
  obj.BufferCommands.vkCmdBeginDebugUtilsLabelEXTCount = 0
  obj.BufferCommands.vkCmdEndDebugUtilsLabelEXTCount = 0
  obj.BufferCommands.vkCmdInsertDebugUtilsLabelEXTCount = 0
  obj.BufferCommands.vkCmdSetDeviceMaskKHRCount = 0
  obj.BufferCommands.vkCmdSetDeviceMaskCount = 0
  obj.BufferCommands.vkCmdDispatchBaseKHRCount = 0
  obj.BufferCommands.vkCmdDispatchBaseCount = 0
}

sub void resetCommandBuffer(ref!CommandBufferObject obj) {
  // Reset the commands instead of clearing them.
  // We have to iterate over them either way, but this way
  // we don't have to free/allocate new memory for the maps
  resetBufferCommands(obj)
  clear(obj.CommandReferences)
  resetCmd(obj.VulkanHandle)
  clear(obj.ImageTransitions)
}

//////////////////////////////
// Secondary command buffer //
//////////////////////////////

@internal
class vkCmdExecuteCommandsArgs {
  dense_map!(u32, VkCommandBuffer) CommandBuffers
}

sub void dovkCmdExecuteCommands(ref!vkCmdExecuteCommandsArgs cmds) {
  enterSubcontext()
  for i in (0 .. len(cmds.CommandBuffers)) {
    cb := CommandBuffers[cmds.CommandBuffers[as!u32(i)]]
    enterSubcontext()
    for j in (0 .. len(cb.CommandReferences)) {
      cmd := cb.CommandReferences[as!u32(j)]
      onPreSubcommand(cmd)
      callCommand(cmd)
      onPostSubcommand(cmd)
      nextSubcontext()
    }
    leaveSubcontext()
    nextSubcontext()
  }
  leaveSubcontext()
}

@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdExecuteCommands(
    VkCommandBuffer        commandBuffer,
    u32                    commandBufferCount,
    const VkCommandBuffer* pCommandBuffers) {
  cmdBuf := CommandBuffers[commandBuffer]
  if cmdBuf == null {
    vkErrorInvalidCommandBuffer(commandBuffer)
  } else {
    mapPos := cmdBuf.BufferCommands.vkCmdExecuteCommandsCount
    cmd_buffers := pCommandBuffers[0:commandBufferCount]
    oldArgs := cmdBuf.BufferCommands.vkCmdExecuteCommands[mapPos]
    args := switch oldArgs == null {
      case true: new!vkCmdExecuteCommandsArgs()
      case false: oldArgs
    }
    clear(args.CommandBuffers)
    for i in (0 .. commandBufferCount) {
      if !(cmd_buffers[i] in CommandBuffers) {
        vkErrorInvalidCommandBuffer(cmd_buffers[i])
      } else {
        args.CommandBuffers[as!u32(i)] = cmd_buffers[i]
      }
      if !(cmd_buffers[i] in CommandBuffers) {
        vkErrorInvalidCommandBuffer(cmd_buffers[i])
      } else {
        child_buf := CommandBuffers[cmd_buffers[i]]
        MergeLayoutTransitions(cmdBuf, child_buf)
      }
    }

    cmdBuf.BufferCommands.vkCmdExecuteCommands[mapPos] = args
    cmdBuf.BufferCommands.vkCmdExecuteCommandsCount = mapPos + 1

    AddCommand(cmdBuf, cmd_vkCmdExecuteCommands, mapPos)
  }
}

// ----------------------------------------------------------------------------
// Vulkan 1.1 Commands
// ----------------------------------------------------------------------------

//////////////////
// Command pool //
//////////////////

sub void TrimCommandPool(
    VkDevice                device,
    VkCommandPool           commandPool,
    VkCommandPoolTrimFlags  flags) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(commandPool in CommandPools) { vkErrorInvalidCommandPool(commandPool) }
}

@since("1.1")
@indirect("VkDevice")
cmd void vkTrimCommandPool(
    VkDevice                device,
    VkCommandPool           commandPool,
    VkCommandPoolTrimFlags  flags) {
  TrimCommandPool(device, commandPool, flags)
}
