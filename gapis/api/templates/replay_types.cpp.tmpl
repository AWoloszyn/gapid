{{/*
 * Copyright (C) 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */}}

{{/* ---- Includes ---- */}}
{{Include "replay_common.tmpl"}}


{{$filename := print (Global "API") "_replay_types.cpp" }}
{{$ | Macro "Types" | Reflow 4 | Write $filename}}

{{define "Types"}}
  {{AssertType $ "API"}}
  {{Template "C++.Copyright"}}
¶
  #include "cmd/read_pack_cpp/{{Global "API"}}_replay_types.h"
  #include "cmd/read_pack_cpp/helpers2.h"
¶
  namespace gapii {«
  class CallObserver;
  {{range $c := $.Classes}}
    {{Template "DefineClassMethods" $c}}
    {{Template "DefineRemap" $c}}
    {{Template "DefineWriteClass" $c}}
  {{end}}
  {{range $c := $.Pseudonyms}}
    {{Template "DefineRemapPseudonym" $c}}
    {{Template "DefineWrite" $c}}
  {{end}}
  {{range $c := $.Enums}}
    {{Template "DefineEnumMethods" $c}}
  {{end}}
  {{Template "DeclareState" $}}
¶
  »} // namespace gapii
¶
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits the definition of member methods of a class.
-------------------------------------------------------------------------------
*/}}
{{define "DefineClassMethods"}}
  {{AssertType $ "Class"}}

  {{$serializable := not (GetAnnotation $ "noserialize")}}
  {{$name := Macro "C++.Type" $}}
  {{if len $.Fields}}
¶
    {{$name}}::{{$name}}()»»
      {{$a := ForEach $.Fields "DeclareDefaultInitializer" | JoinWith "\n, "}}
      {{if $a}}: {{$a}}{{end}}
      ««§•{}
¶
    {{$name}}::{{$name}}(§»
      {{range $i, $f := $.Fields}}
        {{if $i}}, §{{end}}
        {{if (IsStaticArray (TypeOf $f))}}const §{{end}}
        {{Template "C++.Type" $f}} {{$f.Name}}§
      {{end}}
      «)»»
      {{$a := ForEach $.Fields "DeclareCopyInitializer" | JoinWith "\n, "}}
      {{if $a}}: {{$a}}{{end}}
      ««§•{}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the definition of helper methods of a class.
-------------------------------------------------------------------------------
*/}}
{{define "DefineEnumMethods"}}
  {{AssertType $ "Enum"}}
  {{$type := Macro "C++.Type" $.NumberType}}
  namespace {{Template "C++.EnumName" $}} {
    const static {{$type}} allValues[] = {
      {{range $entry := $.Entries}}
        {{Template "C++.EnumEntryName" $entry}},
      {{end}}
    };
    const gapil::Slice<const {{$type}}> values() {
      return gapil::Slice<const {{$type}}>(allValues, {{len $.Entries}});
    }
  }
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the definition for the API state.
-------------------------------------------------------------------------------
*/}}
{{define "DeclareState"}}
  {{AssertType $ "API"}}

  {{$name := print (Title (Global "API")) "State"}}

¶
  {{$name}}::{{$name}}() »»
    {{range $i, $g := $.Globals}}
      {{if $i}}, {{else}}: {{end}}§
      {{$g.Name}}({{Macro "C++.Null" (TypeOf $g)}})§
    {{end}}
    ««§•{}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a default initializer for the field.
-------------------------------------------------------------------------------
*/}}
{{define "DeclareDefaultInitializer"}}
  {{if IsNil $.Default}}
    m{{$.Name}}({{Macro "C++.Null" (TypeOf $)}})
  {{else}}
    m{{$.Name}}({{Macro "C++.Read" $.Default}})
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a field copy initializer.
-------------------------------------------------------------------------------
*/}}
{{define "DeclareCopyInitializer"}}
  m{{$.Name}}({{$.Name}})
{{end}}

{{define "DefineRemapPseudonym"}}
  {{$name := Macro "C++.Type" $}}
  gapil::Slice<{{$name}}> remap_{{$name}}(gapil::Slice<{{$name}}> _x) {
    if(_x.is_app_pool()) {
      for (size_t i = 0; i < _x.count(); ++i) {
        remap_{{$name}}(_x[i]);
      }
    }
    return _x;
  }
  void remap_{{$name}}({{$name}}& _x) {
    {{if (GetAnnotation  $ "replay_remap")}}
      auto it =  m{{$name}}Remaps.find(_x);
      if (it != m{{$name}}Remaps.end()) {
        _x = it->second;
      }
    {{end}}
  }

  {{$name}} remap_{{$name}}(gapil::Slice<{{$name}}> _x, size_t offs) {
    return remap_{{$name}}(gapil::Slice<{{$name}}>(&_x[offs], 1))[0];
  }
{{end}}

{{define "DefineRemap"}}
  {{$name := Macro "C++.Type" $}}

  gapil::Slice<{{$name}}> remap(gapil::Slice<{{$name}}> _x) {
    if(_x.is_app_pool()) {
      for (size_t i = 0; i < _x.count(); ++i) {
        remap(_x[i]);
      }
    }
    return _x;
  }

  {{$name}} remap(gapil::Slice<{{$name}}> _x, size_t offs) {
    return remap(gapil::Slice<{{$name}}>(&_x[offs], 1))[0];
  }
  
  void remap({{$name}}& _x) {
    {{range $f := $.Fields}}
      {{if IsPointer ($f.Type | Underlying)}}
        fixup_pointer((&_x.m{{$f}}));
      {{else if IsClass ($f.Type | Underlying)}}
          remap(_x.m{{$f}});
      {{else if (and (IsPseudonym $f.Type) (GetAnnotation  $f.Type "replay_remap"))}}
        remap_{{Template "C++.Type" $f.Type}}(_x.m{{$f}});
      {{end}}
    {{end}}
  }
{{end}}

{{define "DefineWriteClass"}}
  {{$name := Macro "C++.Type" $}}
  void write_{{$name}}(gapil::Slice<{{$name}}> _x, size_t offs) {
    {{range $f := $.Fields}}
      {{$fType := Macro "C++.Type" $f.Type}}
      {{if IsClass ($f.Type | Underlying)}}
          write_{{$fType}}(gapil::Slice<{{$fType}}>(&_x[offs].m{{$f}}, 1), 0);
      {{else if (and (IsPseudonym $f.Type) (GetAnnotation  $f.Type "replay_remap"))}}
          write_{{$fType}}(gapil::Slice<{{$fType}}>(&_x[offs].m{{$f}}, 1), 0);
      {{end}}
    {{end}}
  }
{{end}}


{{define "DefineWrite"}}
  {{$name := Macro "C++.Type" $}}
  {{if GetAnnotation $ "replay_remap"}}
  std::unordered_map<{{$name}}, {{$name}}> m{{$name}}Remaps;
  {{end}}
  void write_{{$name}}(gapil::Slice<{{$name}}> _x, size_t offs) {
    {{if GetAnnotation $ "replay_remap"}}
      auto ptr = &_x[offs];
      auto val = _x[offs];
      _pending_writes.push_back(pending_write{
        (uintptr_t)ptr, 
        (uintptr_t)sizeof(_x[0]),
        [ptr, val]() {
          m{{$name}}Remaps[ptr[0]] = val;
        }});
    {{end}}
  }
{{end}}