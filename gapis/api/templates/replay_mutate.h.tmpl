{{/*
 * Copyright (C) 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */}}

{{/* ---- Includes ---- */}}
{{Include "api_classnames.tmpl"}}
{{Include "replay_common.tmpl"    }}
{{Global "C++.Statement.Override" "Statement"}}

{{$filename := print (Global "API") "_replay_mutate.h"}}
{{$ | Macro "ReplayCpp" | Reflow 4 | Write $filename}}
{{$fname := print (Global "API") "_replay_subroutines.h"}}
{{$ | Macro "ReplayCppSubroutines" | Reflow 4 | Write $fname}}

{{/*
-------------------------------------------------------------------------------
  Emits all the commands passed in $ into a new C++ file.
-------------------------------------------------------------------------------
*/}}
{{define "ReplayCpp"}}
  {{Template "C++.Copyright"}}
  {{Template "FileHeaders"}}
¶
  namespace gapii {«
¶
  {{ForEach (AllCommands $) "MethodDeclaration" | JoinWith "\n\n"}}
  »} // namespace gapii
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits all the subroutines for the API.
-------------------------------------------------------------------------------
*/}}
{{define "ReplayCppSubroutines"}}
  {{Template "C++.Copyright"}}
  {{Template "FileHeaders"}}
¶
  namespace gapii {«
¶
  {{ForEach $.Subroutines "Subroutine" | JoinWith "\n¶"}}
  {{ForEach $.Externs "Extern" | JoinWith "\n¶"}}
  »} // namespace gapii
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits the headers for a C++ file.
-------------------------------------------------------------------------------
*/}}
{{define "FileHeaders"}}
¶
  #include "{{Global "API"}}_replay_types.h"
  #include "cmd/read_pack_cpp/helpers2.h"
  #include "gapis/api/{{Global "API"}}/{{Global "API"}}_pb/api.pb.h"
¶
  #include "core/cc/log.h"
¶
  #define __STDC_FORMAT_MACROS
  #include <inttypes.h>
¶
  #include <stdint.h>
¶
  #include <memory>
  #include <string>
¶
  // Silence warnings
  #pragma GCC diagnostic ignored "-Wpragmas" // Not all warnings are understood by all compilers!
  #pragma GCC diagnostic ignored "-Wswitch-bool" // switch condition has boolean value
  #pragma GCC diagnostic ignored "-Wunused-variable"
  #pragma GCC diagnostic ignored "-Wunused-lambda-capture"
  #pragma GCC diagnostic ignored "-Wpessimizing-move"
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits an import declaration for an indirected command.
-------------------------------------------------------------------------------
*/}}
{{define "ConcatenateImports"}}
  {{AssertType $.FromClass "string"}}
  {{AssertType $.ToClass   "string"}}
  {{AssertType $.Element   "string"}}
  mState.{{Template "RemoveUpperPrefix" $.FromClass}}s[{{$.Element}}]->m{{Template "RemoveUpperPrefix" $.ToClass}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a validity check for an indirected function pointer.
-------------------------------------------------------------------------------
*/}}
{{define "GetIndirectedFunction"}}
  {{AssertType $.Element    "string"      }}
  {{AssertType $.Function   "string"      }}
  {{$annotation := print (index $.Annotations 0)}}
  {{if eq (len $.Annotations) 1}}
    {{$function_class := Title $annotation}}
    mImports.m{{$function_class}}Functions.find({{$.Element}}) == mImports.m{{$function_class}}Functions.end() ||
    mImports.m{{$function_class}}Functions[{{$.Element}}].{{$.Function}} == nullptr
  {{else}}
    {{$next_annotation := print (index $.Annotations 1)}}
    {{$from_class := $annotation}}
    {{$to_class := $next_annotation}}
    mState.{{Template "RemoveUpperPrefix" (print $from_class)}}s.find({{$.Element}}) == mState.{{Template "RemoveUpperPrefix" (print $from_class)}}s.end() ||
    {{$next_elements := Macro "ConcatenateImports" "FromClass" $from_class "ToClass" $to_class "Element" $.Element}}
    {{Template "GetIndirectedFunction" "Annotations" (Tail 1 $.Annotations) "Element" (print $next_elements) "Function" $.Function}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a reference to a function pointer to an indirected function.
-------------------------------------------------------------------------------
*/}}
{{define "GetIndirectedCall"}}
  {{AssertType $.Element    "string"      }}
  {{AssertType $.Function   "string"      }}
  {{$annotation := index $.Annotations 0}}
  {{if eq (len $.Annotations) 1}}
    {{$function_class := Title $annotation}}
    mImports.m{{$function_class}}Functions[{{$.Element}}].{{$.Function}}
  {{else}}
    {{$next_annotation := index $.Annotations 1}}
    {{$from_class := Title $annotation}}
    {{$to_class := Title $next_annotation}}
    {{$next_elements := Macro "ConcatenateImports" "FromClass" (print $from_class) "ToClass" (print $to_class) "Element" $.Element}}
    {{Template "GetIndirectedCall" "Annotations" (Tail 1 $.Annotations) "Element" (print $next_elements) "Function" $.Function}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the method body for the given command.
-------------------------------------------------------------------------------
*/}}
{{define "MethodDeclaration"}}
  {{AssertType $ "Function"}}
  {{if not (GetAnnotation $ "pfn")}}
    {{$name      := Macro "C++.MethodName" $}}
    {{$spyname   := Global "SpyName"}}
    {{$synthetic := GetAnnotation $ "synthetic"}}
    {{$retTy     := $.Return.Type}}

    {{Template "C++.ReturnType" $}} __{{$name}}({{Macro "C++.CallParameters" $ | JoinWith ", "}});
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ capture list for the call lambda.
-------------------------------------------------------------------------------
*/}}
{{define "CallCapture"}}
  {{AssertType $ "Function"}}

  {{$args := Macro "C++.CallArguments" $}}

  {{if IsVoid $.Return.Type}}
    {{(Strings "this" "&called" $args) | JoinWith ", "}}
  {{else}}
    {{(Strings "this" "&called" "&result" $args) | JoinWith ", "}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the method body for the subroutine.
-------------------------------------------------------------------------------
*/}}
{{define "Subroutine"}}
  {{AssertType $ "Function"}}

  {{$name      := Macro "C++.MethodName" $}}
  {{$spyname   := Global "SpyName"}}
  {{$args      := Strings "const std::function<void()>& call" (Macro "C++.CallParameters" $) | JoinWith ", "}}

  {{Template "C++.SubReturnType" $}} {{$name}}({{$args}});
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits the method body for the extern.
-------------------------------------------------------------------------------
*/}}
{{define "Extern"}}
  {{AssertType $ "Function"}}

  {{$name      := Macro "C++.MethodName" $}}
  {{$spyname   := Global "SpyName"}}
  {{$args      := Strings (Macro "C++.CallParameters" $) | JoinWith ", "}}

  {{Template "C++.SubReturnType" $}} {{$name}}({{$args}});
{{end}}


{{/*
-------------------------------------------------------------------------------
  Override for the "C++.Statement" macro.
-------------------------------------------------------------------------------
*/}}
{{define "Statement"}}
  {{     if IsReturn      $}}{{Template "Return" $}}
  {{else if IsFence       $}}{{Template "Fence" $}}
  {{else if IsCopy        $}}{{Template "Copy" $}}
  {{else if IsRead        $}}{{Template "Read" $}}
  {{else if IsAssign      $}}{{Template "Assign" $}}
  {{else if IsSliceAssign $}}{{Template "SliceAssign" $}}
  {{else                   }}{{Template "C++.Statement.Default" $}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  An override for the "C++.Fence" macro.
-------------------------------------------------------------------------------
*/}}
{{define "Fence"}}
  {{AssertType $ "Fence"}}

  {{if not (IsNil $.Statement)}}
    {{if IsCopy $.Statement}}
      {{/* Apply the fenced-copy read */}}
      {{Template "C++.Type" $.Statement.Dst}} copy__dst__ = copy({{Template "C++.Read" $.Statement.Dst}}, {{Template "C++.Read" $.Statement.Src}});
    {{end}}
  {{end}}

  call();

  {{/* Perform the fenced statement */}}
  {{if not (IsNil $.Statement)}}
    {{if IsCopy $.Statement}}
      write(copy__dst__);
    {{else}}
      {{Template "C++.Statement" $.Statement}}
    {{end}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  An override for the "C++.Return" macro.
-------------------------------------------------------------------------------
*/}}
{{define "Return"}}
  {{AssertType $ "Return"}}

  {{if $.Function.Subroutine}}
    {{Template "C++.Return" $}}
  {{else}}
    break;
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  An override for the "C++.Copy" macro.
-------------------------------------------------------------------------------
*/}}
{{define "Copy"}}
  {{AssertType $ "Copy"}}
  {{if (and (GetAnnotation ($.Src | TargetField) "spy_disabled") ((GetAnnotation ($.Dst | TargetField) "spy_disabled")))}}
    // @spy_disabled
  {{else if GetAnnotation ($.Src | TargetField) "spy_disabled"}}
    {{Error "Attempting to copy from a @spy_disabled slice"}}
  {{else if GetAnnotation ($.Dst | TargetField) "spy_disabled"}}
    //remap({{Template "C++.Read" $.Src}}); // @spy_disabled
  {{else}}
    {{Template "C++.Statement.Default" $}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  An override for the "C++.Read" macro.
-------------------------------------------------------------------------------
*/}}
{{define "Read"}}
  {{AssertType $ "Read"}}
  {{if (GetAnnotation ($.Slice | TargetField) "spy_disabled")}}
    // @spy_disabled
  {{else}}
    {{Template "C++.Statement.Default" $}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  An override for the "C++.Assign" macro.
-------------------------------------------------------------------------------
*/}}
{{define "Assign"}}
  {{AssertType $ "Assign"}}
  {{if (and (GetAnnotation ($.RHS | TargetField) "spy_disabled") ((GetAnnotation ($.LHS | TargetField) "spy_disabled")))}}
    // @spy_disabled
  {{else if GetAnnotation ($.RHS | TargetField) "spy_disabled"}}
    {{Error "Attempting to assign from a @spy_disabled slice"}}
  {{else if GetAnnotation ($.LHS | TargetField) "spy_disabled"}}
    // @spy_disabled
  {{else}}
    {{Template "C++.Statement.Default" $}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  An override for the "C++.SliceAssign" macro.
-------------------------------------------------------------------------------
*/}}
{{define "SliceAssign"}}
  {{AssertType $ "SliceAssign"}}
  {{if (GetAnnotation ($.To.Slice | TargetField) "spy_disabled")}}
    // @spy_disabled
  {{else}}
    {{Template "C++.Statement.Default" $}}
  {{end}}
{{end}}